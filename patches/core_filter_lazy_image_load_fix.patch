diff --git a/web/core/modules/filter/css/filter.caption.css b/web/core/modules/filter/css/filter.caption.css
index 327b7330..34c0b1b8 100644
--- a/web/core/modules/filter/css/filter.caption.css
+++ b/web/core/modules/filter/css/filter.caption.css
@@ -24,7 +24,7 @@
  *
  * Based on http://codepen.io/flesler/pen/AEIFc.
  */
-.caption > figcaption[contenteditable=true]:empty:before {
+.caption > figcaption[contenteditable=true]:empty::before {
   content: attr(data-placeholder);
   font-style: italic;
 }
diff --git a/web/core/modules/filter/filter.admin.es6.js b/web/core/modules/filter/filter.admin.es6.js
deleted file mode 100644
index 731ed5b7..00000000
--- a/web/core/modules/filter/filter.admin.es6.js
+++ /dev/null
@@ -1,74 +0,0 @@
-/**
- * @file
- * Attaches administration-specific behavior for the Filter module.
- */
-
-(function ($, Drupal) {
-  /**
-   * Displays and updates the status of filters on the admin page.
-   *
-   * @type {Drupal~behavior}
-   *
-   * @prop {Drupal~behaviorAttach} attach
-   *   Attaches behaviors to the filter admin view.
-   */
-  Drupal.behaviors.filterStatus = {
-    attach(context, settings) {
-      const $context = $(context);
-      once(
-        'filter-status',
-        '#filters-status-wrapper input.form-checkbox',
-        context,
-      ).forEach((checkbox) => {
-        const $checkbox = $(checkbox);
-        // Retrieve the tabledrag row belonging to this filter.
-        const $row = $context
-          .find(`#${$checkbox.attr('id').replace(/-status$/, '-weight')}`)
-          .closest('tr');
-        // Retrieve the vertical tab belonging to this filter.
-        const $filterSettings = $context.find(
-          `[data-drupal-selector='${$checkbox
-            .attr('id')
-            .replace(/-status$/, '-settings')}']`,
-        );
-        const filterSettingsTab = $filterSettings.data('verticalTab');
-
-        // Bind click handler to this checkbox to conditionally show and hide
-        // the filter's tableDrag row and vertical tab pane.
-        $checkbox.on('click.filterUpdate', () => {
-          if ($checkbox.is(':checked')) {
-            $row.show();
-            if (filterSettingsTab) {
-              filterSettingsTab.tabShow().updateSummary();
-            } else {
-              // On very narrow viewports, Vertical Tabs are disabled.
-              $filterSettings.show();
-            }
-          } else {
-            $row.hide();
-            if (filterSettingsTab) {
-              filterSettingsTab.tabHide().updateSummary();
-            } else {
-              // On very narrow viewports, Vertical Tabs are disabled.
-              $filterSettings.hide();
-            }
-          }
-          // Restripe table after toggling visibility of table row.
-          Drupal.tableDrag['filter-order'].restripeTable();
-        });
-
-        // Attach summary for configurable filters (only for screen readers).
-        if (filterSettingsTab) {
-          filterSettingsTab.details.drupalSetSummary(() =>
-            $checkbox.is(':checked')
-              ? Drupal.t('Enabled')
-              : Drupal.t('Disabled'),
-          );
-        }
-
-        // Trigger our bound click handler to update elements to initial state.
-        $checkbox.triggerHandler('click.filterUpdate');
-      });
-    },
-  };
-})(jQuery, Drupal);
diff --git a/web/core/modules/filter/filter.admin.js b/web/core/modules/filter/filter.admin.js
index ea43f143..731ed5b7 100644
--- a/web/core/modules/filter/filter.admin.js
+++ b/web/core/modules/filter/filter.admin.js
@@ -1,24 +1,47 @@
 /**
-* DO NOT EDIT THIS FILE.
-* See the following change record for more information,
-* https://www.drupal.org/node/2815083
-* @preserve
-**/
+ * @file
+ * Attaches administration-specific behavior for the Filter module.
+ */
+
 (function ($, Drupal) {
+  /**
+   * Displays and updates the status of filters on the admin page.
+   *
+   * @type {Drupal~behavior}
+   *
+   * @prop {Drupal~behaviorAttach} attach
+   *   Attaches behaviors to the filter admin view.
+   */
   Drupal.behaviors.filterStatus = {
-    attach: function attach(context, settings) {
-      var $context = $(context);
-      once('filter-status', '#filters-status-wrapper input.form-checkbox', context).forEach(function (checkbox) {
-        var $checkbox = $(checkbox);
-        var $row = $context.find("#".concat($checkbox.attr('id').replace(/-status$/, '-weight'))).closest('tr');
-        var $filterSettings = $context.find("[data-drupal-selector='".concat($checkbox.attr('id').replace(/-status$/, '-settings'), "']"));
-        var filterSettingsTab = $filterSettings.data('verticalTab');
-        $checkbox.on('click.filterUpdate', function () {
+    attach(context, settings) {
+      const $context = $(context);
+      once(
+        'filter-status',
+        '#filters-status-wrapper input.form-checkbox',
+        context,
+      ).forEach((checkbox) => {
+        const $checkbox = $(checkbox);
+        // Retrieve the tabledrag row belonging to this filter.
+        const $row = $context
+          .find(`#${$checkbox.attr('id').replace(/-status$/, '-weight')}`)
+          .closest('tr');
+        // Retrieve the vertical tab belonging to this filter.
+        const $filterSettings = $context.find(
+          `[data-drupal-selector='${$checkbox
+            .attr('id')
+            .replace(/-status$/, '-settings')}']`,
+        );
+        const filterSettingsTab = $filterSettings.data('verticalTab');
+
+        // Bind click handler to this checkbox to conditionally show and hide
+        // the filter's tableDrag row and vertical tab pane.
+        $checkbox.on('click.filterUpdate', () => {
           if ($checkbox.is(':checked')) {
             $row.show();
             if (filterSettingsTab) {
               filterSettingsTab.tabShow().updateSummary();
             } else {
+              // On very narrow viewports, Vertical Tabs are disabled.
               $filterSettings.show();
             }
           } else {
@@ -26,18 +49,26 @@
             if (filterSettingsTab) {
               filterSettingsTab.tabHide().updateSummary();
             } else {
+              // On very narrow viewports, Vertical Tabs are disabled.
               $filterSettings.hide();
             }
           }
+          // Restripe table after toggling visibility of table row.
           Drupal.tableDrag['filter-order'].restripeTable();
         });
+
+        // Attach summary for configurable filters (only for screen readers).
         if (filterSettingsTab) {
-          filterSettingsTab.details.drupalSetSummary(function () {
-            return $checkbox.is(':checked') ? Drupal.t('Enabled') : Drupal.t('Disabled');
-          });
+          filterSettingsTab.details.drupalSetSummary(() =>
+            $checkbox.is(':checked')
+              ? Drupal.t('Enabled')
+              : Drupal.t('Disabled'),
+          );
         }
+
+        // Trigger our bound click handler to update elements to initial state.
         $checkbox.triggerHandler('click.filterUpdate');
       });
-    }
+    },
   };
-})(jQuery, Drupal);
\ No newline at end of file
+})(jQuery, Drupal);
diff --git a/web/core/modules/filter/filter.es6.js b/web/core/modules/filter/filter.es6.js
deleted file mode 100644
index 733dc93f..00000000
--- a/web/core/modules/filter/filter.es6.js
+++ /dev/null
@@ -1,39 +0,0 @@
-/**
- * @file
- * Attaches behavior for the Filter module.
- */
-
-(function ($, Drupal) {
-  /**
-   * Displays the guidelines of the selected text format automatically.
-   *
-   * @type {Drupal~behavior}
-   *
-   * @prop {Drupal~behaviorAttach} attach
-   *   Attaches behavior for updating filter guidelines.
-   */
-  Drupal.behaviors.filterGuidelines = {
-    attach(context) {
-      function updateFilterGuidelines(event) {
-        const $this = $(event.target);
-        const { value } = event.target;
-        $this
-          .closest('.js-filter-wrapper')
-          .find('[data-drupal-format-id]')
-          .hide()
-          .filter(`[data-drupal-format-id="${value}"]`)
-          .show();
-      }
-
-      $(once('filter-guidelines', '.js-filter-guidelines', context))
-        .find(':header')
-        .hide()
-        .closest('.js-filter-wrapper')
-        .find('select.js-filter-list')
-        .on('change.filterGuidelines', updateFilterGuidelines)
-        // Need to trigger the namespaced event to avoid triggering formUpdated
-        // when initializing the select.
-        .trigger('change.filterGuidelines');
-    },
-  };
-})(jQuery, Drupal);
diff --git a/web/core/modules/filter/filter.filter_html.admin.es6.js b/web/core/modules/filter/filter.filter_html.admin.es6.js
deleted file mode 100644
index 8701fab0..00000000
--- a/web/core/modules/filter/filter.filter_html.admin.es6.js
+++ /dev/null
@@ -1,404 +0,0 @@
-/**
- * @file
- * Attaches behavior for updating filter_html's settings automatically.
- */
-
-(function ($, Drupal, document) {
-  if (Drupal.filterConfiguration) {
-    /**
-     * Implement a live setting parser to prevent text editors from automatically
-     * enabling buttons that are not allowed by this filter's configuration.
-     *
-     * @namespace
-     */
-    Drupal.filterConfiguration.liveSettingParsers.filter_html = {
-      /**
-       * @return {Array}
-       *   An array of filter rules.
-       */
-      getRules() {
-        const currentValue = document.querySelector(
-          '#edit-filters-filter-html-settings-allowed-html',
-        ).value;
-        const rules =
-          Drupal.behaviors.filterFilterHtmlUpdating._parseSetting(currentValue);
-
-        // Build a FilterHTMLRule that reflects the hard-coded behavior that
-        // strips all "style" attribute and all "on*" attributes.
-        const rule = new Drupal.FilterHTMLRule();
-        rule.restrictedTags.tags = ['*'];
-        rule.restrictedTags.forbidden.attributes = ['style', 'on*'];
-        rules.push(rule);
-
-        return rules;
-      },
-    };
-  }
-
-  /**
-   * Gets the values that are present in one array but not another.
-   *
-   * @param {Array[]} args
-   *   The list of arrays to process.
-   *
-   * @return {Array}
-   *   Returns the first array without the values present in other arrays.
-   */
-  function difference(...args) {
-    return args.reduce((mainData, otherData) =>
-      mainData.filter((data) => !otherData.includes(data)),
-    );
-  }
-
-  /**
-   * Displays and updates what HTML tags are allowed to use in a filter.
-   *
-   * @type {Drupal~behavior}
-   *
-   * @todo Remove everything but 'attach' and 'detach' and make a proper object.
-   *
-   * @prop {Drupal~behaviorAttach} attach
-   *   Attaches behavior for updating allowed HTML tags.
-   */
-  Drupal.behaviors.filterFilterHtmlUpdating = {
-    // The form item contains the "Allowed HTML tags" setting.
-    $allowedHTMLFormItem: null,
-
-    // The description for the "Allowed HTML tags" field.
-    $allowedHTMLDescription: null,
-
-    /**
-     * The parsed, user-entered tag list of $allowedHTMLFormItem
-     *
-     * @var {Object.<string, Drupal.FilterHTMLRule>}
-     */
-    userTags: {},
-
-    // The auto-created tag list thus far added.
-    autoTags: null,
-
-    // Track which new features have been added to the text editor.
-    newFeatures: {},
-
-    attach(context, settings) {
-      const that = this;
-      once(
-        'filter-filter_html-updating',
-        '[name="filters[filter_html][settings][allowed_html]"]',
-        context,
-      ).forEach((formItem) => {
-        that.$allowedHTMLFormItem = $(formItem);
-        that.$allowedHTMLDescription = that.$allowedHTMLFormItem
-          .closest('.js-form-item')
-          .find('#edit-filters-filter-html-settings-allowed-html--description');
-        that.userTags = that._parseSetting(formItem.value);
-
-        // Update the new allowed tags based on added text editor features.
-        $(document)
-          .on('drupalEditorFeatureAdded', (e, feature) => {
-            that.newFeatures[feature.name] = feature.rules;
-            that._updateAllowedTags();
-          })
-          .on('drupalEditorFeatureModified', (e, feature) => {
-            if (that.newFeatures.hasOwnProperty(feature.name)) {
-              that.newFeatures[feature.name] = feature.rules;
-              that._updateAllowedTags();
-            }
-          })
-          .on('drupalEditorFeatureRemoved', (e, feature) => {
-            if (that.newFeatures.hasOwnProperty(feature.name)) {
-              delete that.newFeatures[feature.name];
-              that._updateAllowedTags();
-            }
-          });
-
-        // When the allowed tags list is manually changed, update userTags.
-        that.$allowedHTMLFormItem.on('change.updateUserTags', function () {
-          that.userTags = difference(
-            Object.values(that._parseSetting(this.value)),
-            Object.values(that.autoTags),
-          );
-        });
-      });
-    },
-
-    /**
-     * Updates the "Allowed HTML tags" setting and shows an informative message.
-     */
-    _updateAllowedTags() {
-      // Update the list of auto-created tags.
-      this.autoTags = this._calculateAutoAllowedTags(
-        this.userTags,
-        this.newFeatures,
-      );
-
-      // Remove any previous auto-created tag message.
-      this.$allowedHTMLDescription.find('.editor-update-message').remove();
-
-      // If any auto-created tags: insert message and update form item.
-      if (Object.keys(this.autoTags).length > 0) {
-        this.$allowedHTMLDescription.append(
-          Drupal.theme('filterFilterHTMLUpdateMessage', this.autoTags),
-        );
-
-        const userTagsWithoutOverrides = {};
-        Object.keys(this.userTags)
-          .filter((tag) => !this.autoTags.hasOwnProperty(tag))
-          .forEach((tag) => {
-            userTagsWithoutOverrides[tag] = this.userTags[tag];
-          });
-
-        this.$allowedHTMLFormItem.val(
-          `${this._generateSetting(
-            userTagsWithoutOverrides,
-          )} ${this._generateSetting(this.autoTags)}`,
-        );
-      }
-      // Restore to original state.
-      else {
-        this.$allowedHTMLFormItem.val(this._generateSetting(this.userTags));
-      }
-    },
-
-    /**
-     * Calculates which HTML tags the added text editor buttons need to work.
-     *
-     * The filter_html filter is only concerned with the required tags, not with
-     * any properties, nor with each feature's "allowed" tags.
-     *
-     * @param {Array} userAllowedTags
-     *   The list of user-defined allowed tags.
-     * @param {object} newFeatures
-     *   A list of {@link Drupal.EditorFeature} objects' rules, keyed by
-     *   their name.
-     *
-     * @return {Array}
-     *   A list of new allowed tags.
-     */
-    _calculateAutoAllowedTags(userAllowedTags, newFeatures) {
-      const editorRequiredTags = {};
-
-      // Map the newly added Text Editor features to Drupal.FilterHtmlRule
-      // objects (to allow comparing userTags with autoTags).
-      Object.keys(newFeatures || {}).forEach((featureName) => {
-        const feature = newFeatures[featureName];
-        let featureRule;
-        let filterRule;
-        let tag;
-
-        for (let f = 0; f < feature.length; f++) {
-          featureRule = feature[f];
-          for (let t = 0; t < featureRule.required.tags.length; t++) {
-            tag = featureRule.required.tags[t];
-            if (!editorRequiredTags.hasOwnProperty(tag)) {
-              filterRule = new Drupal.FilterHTMLRule();
-              filterRule.restrictedTags.tags = [tag];
-              // @todo Neither Drupal.FilterHtmlRule nor
-              //   Drupal.EditorFeatureHTMLRule allow for generic attribute
-              //   value restrictions, only for the "class" and "style"
-              //   attribute's values to be restricted. The filter_html filter
-              //   always disallows the "style" attribute, so we only need to
-              //   support "class" attribute value restrictions. Fix once
-              //   https://www.drupal.org/node/2567801 lands.
-              filterRule.restrictedTags.allowed.attributes =
-                featureRule.required.attributes.slice(0);
-              if (
-                userAllowedTags[tag] !== undefined &&
-                userAllowedTags[tag].restrictedTags.allowed.classes[0] !== ''
-              ) {
-                filterRule.restrictedTags.allowed.classes =
-                  featureRule.required.classes.slice(0);
-              }
-              editorRequiredTags[tag] = filterRule;
-            }
-            // The tag is already allowed, add any additionally allowed
-            // attributes.
-            else {
-              filterRule = editorRequiredTags[tag];
-              filterRule.restrictedTags.allowed.attributes = [
-                ...filterRule.restrictedTags.allowed.attributes,
-                ...featureRule.required.attributes,
-              ];
-              if (
-                userAllowedTags[tag] !== undefined &&
-                userAllowedTags[tag].restrictedTags.allowed.classes[0] !== ''
-              ) {
-                filterRule.restrictedTags.allowed.classes = [
-                  ...filterRule.restrictedTags.allowed.classes,
-                  ...featureRule.required.classes,
-                ];
-              }
-            }
-          }
-        }
-      });
-
-      // Now compare userAllowedTags with editorRequiredTags, and build
-      // autoAllowedTags, which contains:
-      // - any tags in editorRequiredTags but not in userAllowedTags (i.e. tags
-      //   that are additionally going to be allowed)
-      // - any tags in editorRequiredTags that already exists in userAllowedTags
-      //   but does not allow all attributes or attribute values
-      const autoAllowedTags = {};
-      Object.keys(editorRequiredTags).forEach((tag) => {
-        // If userAllowedTags does not contain a rule for this editor-required
-        // tag, then add it to the list of automatically allowed tags.
-        if (!userAllowedTags.hasOwnProperty(tag)) {
-          autoAllowedTags[tag] = editorRequiredTags[tag];
-        }
-        // Otherwise, if userAllowedTags already allows this tag, then check if
-        // additional attributes and classes on this tag are required by the
-        // editor.
-        else {
-          const requiredAttributes =
-            editorRequiredTags[tag].restrictedTags.allowed.attributes;
-          const allowedAttributes =
-            userAllowedTags[tag].restrictedTags.allowed.attributes;
-          const needsAdditionalAttributes =
-            requiredAttributes.length &&
-            difference(requiredAttributes, allowedAttributes).length;
-          const requiredClasses =
-            editorRequiredTags[tag].restrictedTags.allowed.classes;
-          const allowedClasses =
-            userAllowedTags[tag].restrictedTags.allowed.classes;
-          const needsAdditionalClasses =
-            requiredClasses.length &&
-            difference(requiredClasses, allowedClasses).length;
-          if (needsAdditionalAttributes || needsAdditionalClasses) {
-            autoAllowedTags[tag] = userAllowedTags[tag].clone();
-          }
-          if (needsAdditionalAttributes) {
-            autoAllowedTags[tag].restrictedTags.allowed.attributes = [
-              ...allowedAttributes,
-              ...requiredAttributes,
-            ];
-          }
-          if (needsAdditionalClasses) {
-            autoAllowedTags[tag].restrictedTags.allowed.classes = [
-              ...allowedClasses,
-              ...requiredClasses,
-            ];
-          }
-        }
-      });
-
-      return autoAllowedTags;
-    },
-
-    /**
-     * Parses the value of this.$allowedHTMLFormItem.
-     *
-     * @param {string} setting
-     *   The string representation of the setting. For example:
-     *     <p class="callout"> <br> <a href hreflang>
-     *
-     * @return {Object.<string, Drupal.FilterHTMLRule>}
-     *   The corresponding text filter HTML rule objects, one per tag, keyed by
-     *   tag name.
-     */
-    _parseSetting(setting) {
-      let tag;
-      let rule;
-      let attributes;
-      let attribute;
-
-      const allowedTags = setting.match(/(<[^>]+>)/g);
-      const rules = {};
-      for (let t = 0; t < allowedTags.length; t++) {
-        // Create a jQuery object, making it possible to easily retrieve the
-        // tag name of the allowed tag, regardless of what attributes are set or
-        // what its required parent elements are.
-        const $tagObject = $(allowedTags[t]);
-
-        // Parse the tag name from the jQuery object.
-        tag = $tagObject.prop('tagName').toLowerCase();
-
-        // Build the Drupal.FilterHtmlRule object.
-        rule = new Drupal.FilterHTMLRule();
-        // We create one rule per allowed tag, so always one tag.
-        rule.restrictedTags.tags = [tag];
-
-        // Add the attribute restrictions.
-        attributes = $tagObject.prop('attributes');
-        for (let i = 0; i < attributes.length; i++) {
-          attribute = attributes.item(i);
-          const attributeName = attribute.nodeName;
-          // @todo Drupal.FilterHtmlRule does not allow for generic attribute
-          //   value restrictions, only for the "class" and "style" attribute's
-          //   values. The filter_html filter always disallows the "style"
-          //   attribute, so we only need to support "class" attribute value
-          //   restrictions. Fix once https://www.drupal.org/node/2567801 lands.
-          if (attributeName === 'class') {
-            const attributeValue = attribute.textContent;
-            rule.restrictedTags.allowed.classes = attributeValue.split(' ');
-          } else {
-            rule.restrictedTags.allowed.attributes.push(attributeName);
-          }
-        }
-
-        rules[tag] = rule;
-      }
-      return rules;
-    },
-
-    /**
-     * Generates the value of this.$allowedHTMLFormItem.
-     *
-     * @param {Object.<string, Drupal.FilterHTMLRule>} tags
-     *   The parsed representation of the setting.
-     *
-     * @return {Array}
-     *   The string representation of the setting. e.g. "<p> <br> <a>"
-     */
-    _generateSetting(tags) {
-      return Object.keys(tags).reduce((setting, tag) => {
-        const rule = tags[tag];
-        const allowedClasses = rule.restrictedTags.allowed.classes;
-
-        if (setting.length) {
-          setting += ' ';
-        }
-
-        setting += `<${tag}`;
-        if (rule.restrictedTags.allowed.attributes.length) {
-          setting += ` ${rule.restrictedTags.allowed.attributes.join(' ')}`;
-        }
-        // @todo Drupal.FilterHtmlRule does not allow for generic attribute
-        //   value restrictions, only for the "class" and "style" attribute's
-        //   values. The filter_html filter always disallows the "style"
-        //   attribute, so we only need to support "class" attribute value
-        //   restrictions. Fix once https://www.drupal.org/node/2567801 lands.
-        if (allowedClasses.length === 1 && allowedClasses[0] === '') {
-          setting += ' class';
-        } else if (allowedClasses.length) {
-          setting += ` class="${allowedClasses.join(' ')}"`;
-        }
-
-        setting += '>';
-        return setting;
-      }, '');
-    },
-  };
-
-  /**
-   * Theme function for the filter_html update message.
-   *
-   * @param {Array} tags
-   *   An array of the new tags that are to be allowed.
-   *
-   * @return {string}
-   *   The corresponding HTML.
-   */
-  Drupal.theme.filterFilterHTMLUpdateMessage = function (tags) {
-    let html = '';
-    const tagList =
-      Drupal.behaviors.filterFilterHtmlUpdating._generateSetting(tags);
-    html += '<p class="editor-update-message">';
-    html += Drupal.t(
-      'Based on the text editor configuration, these tags have automatically been added: <strong>@tag-list</strong>.',
-      { '@tag-list': tagList },
-    );
-    html += '</p>';
-    return html;
-  };
-})(jQuery, Drupal, document);
diff --git a/web/core/modules/filter/filter.filter_html.admin.js b/web/core/modules/filter/filter.filter_html.admin.js
index 6e126b43..c8308797 100644
--- a/web/core/modules/filter/filter.filter_html.admin.js
+++ b/web/core/modules/filter/filter.filter_html.admin.js
@@ -1,196 +1,407 @@
 /**
-* DO NOT EDIT THIS FILE.
-* See the following change record for more information,
-* https://www.drupal.org/node/2815083
-* @preserve
-**/
-function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
-function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
-function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
-function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
-function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
-function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
+ * @file
+ * Attaches behavior for updating filter_html's settings automatically.
+ */
+
 (function ($, Drupal, document) {
   if (Drupal.filterConfiguration) {
+    /**
+     * Implement a live setting parser to prevent text editors from
+     * automatically enabling buttons that are not allowed by this filter's
+     * configuration.
+     *
+     * @namespace
+     */
     Drupal.filterConfiguration.liveSettingParsers.filter_html = {
-      getRules: function getRules() {
-        var currentValue = document.querySelector('#edit-filters-filter-html-settings-allowed-html').value;
-        var rules = Drupal.behaviors.filterFilterHtmlUpdating._parseSetting(currentValue);
-        var rule = new Drupal.FilterHTMLRule();
+      /**
+       * @return {Array}
+       *   An array of filter rules.
+       */
+      getRules() {
+        const currentValue = document.querySelector(
+          '#edit-filters-filter-html-settings-allowed-html',
+        ).value;
+        const rules =
+          Drupal.behaviors.filterFilterHtmlUpdating._parseSetting(currentValue);
+
+        // Build a FilterHTMLRule that reflects the hard-coded behavior that
+        // strips all "style" attribute and all "on*" attributes.
+        const rule = new Drupal.FilterHTMLRule();
         rule.restrictedTags.tags = ['*'];
         rule.restrictedTags.forbidden.attributes = ['style', 'on*'];
         rules.push(rule);
+
         return rules;
-      }
+      },
     };
   }
-  function difference() {
-    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
-      args[_key] = arguments[_key];
-    }
-    return args.reduce(function (mainData, otherData) {
-      return mainData.filter(function (data) {
-        return !otherData.includes(data);
-      });
-    });
+
+  /**
+   * Gets the values that are present in one array but not another.
+   *
+   * @param {Array[]} args
+   *   The list of arrays to process.
+   *
+   * @return {Array}
+   *   Returns the first array without the values present in other arrays.
+   */
+  function difference(...args) {
+    return args.reduce((mainData, otherData) =>
+      mainData.filter((data) => !otherData.includes(data)),
+    );
   }
+
+  /**
+   * Displays and updates what HTML tags are allowed to use in a filter.
+   *
+   * @type {Drupal~behavior}
+   *
+   * @todo Remove everything but 'attach' and 'detach' and make a proper object.
+   *
+   * @prop {Drupal~behaviorAttach} attach
+   *   Attaches behavior for updating allowed HTML tags.
+   */
   Drupal.behaviors.filterFilterHtmlUpdating = {
+    // The form item contains the "Allowed HTML tags" setting.
     $allowedHTMLFormItem: null,
+
+    // The description for the "Allowed HTML tags" field.
     $allowedHTMLDescription: null,
+
+    /**
+     * The parsed, user-entered tag list of $allowedHTMLFormItem
+     *
+     * @var {Object.<string, Drupal.FilterHTMLRule>}
+     */
     userTags: {},
+
+    // The auto-created tag list thus far added.
     autoTags: null,
+
+    // Track which new features have been added to the text editor.
     newFeatures: {},
-    attach: function attach(context, settings) {
-      var that = this;
-      once('filter-filter_html-updating', '[name="filters[filter_html][settings][allowed_html]"]', context).forEach(function (formItem) {
+
+    attach(context, settings) {
+      const that = this;
+      once(
+        'filter-filter_html-updating',
+        '[name="filters[filter_html][settings][allowed_html]"]',
+        context,
+      ).forEach((formItem) => {
         that.$allowedHTMLFormItem = $(formItem);
-        that.$allowedHTMLDescription = that.$allowedHTMLFormItem.closest('.js-form-item').find('#edit-filters-filter-html-settings-allowed-html--description');
+        that.$allowedHTMLDescription = that.$allowedHTMLFormItem
+          .closest('.js-form-item')
+          .find('#edit-filters-filter-html-settings-allowed-html--description');
         that.userTags = that._parseSetting(formItem.value);
-        $(document).on('drupalEditorFeatureAdded', function (e, feature) {
-          that.newFeatures[feature.name] = feature.rules;
-          that._updateAllowedTags();
-        }).on('drupalEditorFeatureModified', function (e, feature) {
-          if (that.newFeatures.hasOwnProperty(feature.name)) {
+
+        // Update the new allowed tags based on added text editor features.
+        $(document)
+          .on('drupalEditorFeatureAdded', (e, feature) => {
             that.newFeatures[feature.name] = feature.rules;
             that._updateAllowedTags();
-          }
-        }).on('drupalEditorFeatureRemoved', function (e, feature) {
-          if (that.newFeatures.hasOwnProperty(feature.name)) {
-            delete that.newFeatures[feature.name];
-            that._updateAllowedTags();
-          }
-        });
-        that.$allowedHTMLFormItem.on('change.updateUserTags', function () {
-          that.userTags = difference(Object.values(that._parseSetting(this.value)), Object.values(that.autoTags));
-        });
+          })
+          .on('drupalEditorFeatureModified', (e, feature) => {
+            if (that.newFeatures.hasOwnProperty(feature.name)) {
+              that.newFeatures[feature.name] = feature.rules;
+              that._updateAllowedTags();
+            }
+          })
+          .on('drupalEditorFeatureRemoved', (e, feature) => {
+            if (that.newFeatures.hasOwnProperty(feature.name)) {
+              delete that.newFeatures[feature.name];
+              that._updateAllowedTags();
+            }
+          });
+
+        // When the allowed tags list is manually changed, update userTags.
+        if (that.autoTags) {
+          that.$allowedHTMLFormItem.on('change.updateUserTags', function () {
+            that.userTags = difference(
+              Object.values(that._parseSetting(this.value)),
+              Object.values(that.autoTags),
+            );
+          });
+        }
       });
     },
-    _updateAllowedTags: function _updateAllowedTags() {
-      var _this = this;
-      this.autoTags = this._calculateAutoAllowedTags(this.userTags, this.newFeatures);
+
+    /**
+     * Updates the "Allowed HTML tags" setting and shows an informative message.
+     */
+    _updateAllowedTags() {
+      // Update the list of auto-created tags.
+      this.autoTags = this._calculateAutoAllowedTags(
+        this.userTags,
+        this.newFeatures,
+      );
+
+      // Remove any previous auto-created tag message.
       this.$allowedHTMLDescription.find('.editor-update-message').remove();
+
+      // If any auto-created tags: insert message and update form item.
       if (Object.keys(this.autoTags).length > 0) {
-        this.$allowedHTMLDescription.append(Drupal.theme('filterFilterHTMLUpdateMessage', this.autoTags));
-        var userTagsWithoutOverrides = {};
-        Object.keys(this.userTags).filter(function (tag) {
-          return !_this.autoTags.hasOwnProperty(tag);
-        }).forEach(function (tag) {
-          userTagsWithoutOverrides[tag] = _this.userTags[tag];
-        });
-        this.$allowedHTMLFormItem.val("".concat(this._generateSetting(userTagsWithoutOverrides), " ").concat(this._generateSetting(this.autoTags)));
-      } else {
+        this.$allowedHTMLDescription.append(
+          Drupal.theme('filterFilterHTMLUpdateMessage', this.autoTags),
+        );
+
+        const userTagsWithoutOverrides = {};
+        Object.keys(this.userTags)
+          .filter((tag) => !this.autoTags.hasOwnProperty(tag))
+          .forEach((tag) => {
+            userTagsWithoutOverrides[tag] = this.userTags[tag];
+          });
+
+        this.$allowedHTMLFormItem.val(
+          `${this._generateSetting(
+            userTagsWithoutOverrides,
+          )} ${this._generateSetting(this.autoTags)}`,
+        );
+      }
+      // Restore to original state.
+      else {
         this.$allowedHTMLFormItem.val(this._generateSetting(this.userTags));
       }
     },
-    _calculateAutoAllowedTags: function _calculateAutoAllowedTags(userAllowedTags, newFeatures) {
-      var editorRequiredTags = {};
-      Object.keys(newFeatures || {}).forEach(function (featureName) {
-        var feature = newFeatures[featureName];
-        var featureRule;
-        var filterRule;
-        var tag;
-        for (var f = 0; f < feature.length; f++) {
+
+    /**
+     * Calculates which HTML tags the added text editor buttons need to work.
+     *
+     * The filter_html filter is only concerned with the required tags, not with
+     * any properties, nor with each feature's "allowed" tags.
+     *
+     * @param {Array} userAllowedTags
+     *   The list of user-defined allowed tags.
+     * @param {object} newFeatures
+     *   A list of {@link Drupal.EditorFeature} objects' rules, keyed by
+     *   their name.
+     *
+     * @return {Array}
+     *   A list of new allowed tags.
+     */
+    _calculateAutoAllowedTags(userAllowedTags, newFeatures) {
+      const editorRequiredTags = {};
+
+      // Map the newly added Text Editor features to Drupal.FilterHtmlRule
+      // objects (to allow comparing userTags with autoTags).
+      Object.keys(newFeatures || {}).forEach((featureName) => {
+        const feature = newFeatures[featureName];
+        let featureRule;
+        let filterRule;
+        let tag;
+
+        for (let f = 0; f < feature.length; f++) {
           featureRule = feature[f];
-          for (var t = 0; t < featureRule.required.tags.length; t++) {
+          for (let t = 0; t < featureRule.required.tags.length; t++) {
             tag = featureRule.required.tags[t];
             if (!editorRequiredTags.hasOwnProperty(tag)) {
               filterRule = new Drupal.FilterHTMLRule();
               filterRule.restrictedTags.tags = [tag];
-              filterRule.restrictedTags.allowed.attributes = featureRule.required.attributes.slice(0);
-              if (userAllowedTags[tag] !== undefined && userAllowedTags[tag].restrictedTags.allowed.classes[0] !== '') {
-                filterRule.restrictedTags.allowed.classes = featureRule.required.classes.slice(0);
+              // @todo Neither Drupal.FilterHtmlRule nor
+              //   Drupal.EditorFeatureHTMLRule allow for generic attribute
+              //   value restrictions, only for the "class" and "style"
+              //   attribute's values to be restricted. The filter_html filter
+              //   always disallows the "style" attribute, so we only need to
+              //   support "class" attribute value restrictions. Fix once
+              //   https://www.drupal.org/node/2567801 lands.
+              filterRule.restrictedTags.allowed.attributes =
+                featureRule.required.attributes.slice(0);
+              if (
+                userAllowedTags[tag] !== undefined &&
+                userAllowedTags[tag].restrictedTags.allowed.classes[0] !== ''
+              ) {
+                filterRule.restrictedTags.allowed.classes =
+                  featureRule.required.classes.slice(0);
               }
               editorRequiredTags[tag] = filterRule;
-            } else {
+            }
+            // The tag is already allowed, add any additionally allowed
+            // attributes.
+            else {
               filterRule = editorRequiredTags[tag];
-              filterRule.restrictedTags.allowed.attributes = [].concat(_toConsumableArray(filterRule.restrictedTags.allowed.attributes), _toConsumableArray(featureRule.required.attributes));
-              if (userAllowedTags[tag] !== undefined && userAllowedTags[tag].restrictedTags.allowed.classes[0] !== '') {
-                filterRule.restrictedTags.allowed.classes = [].concat(_toConsumableArray(filterRule.restrictedTags.allowed.classes), _toConsumableArray(featureRule.required.classes));
+              filterRule.restrictedTags.allowed.attributes = [
+                ...filterRule.restrictedTags.allowed.attributes,
+                ...featureRule.required.attributes,
+              ];
+              if (
+                userAllowedTags[tag] !== undefined &&
+                userAllowedTags[tag].restrictedTags.allowed.classes[0] !== ''
+              ) {
+                filterRule.restrictedTags.allowed.classes = [
+                  ...filterRule.restrictedTags.allowed.classes,
+                  ...featureRule.required.classes,
+                ];
               }
             }
           }
         }
       });
-      var autoAllowedTags = {};
-      Object.keys(editorRequiredTags).forEach(function (tag) {
+
+      // Now compare userAllowedTags with editorRequiredTags, and build
+      // autoAllowedTags, which contains:
+      // - any tags in editorRequiredTags but not in userAllowedTags (i.e. tags
+      //   that are additionally going to be allowed)
+      // - any tags in editorRequiredTags that already exists in userAllowedTags
+      //   but does not allow all attributes or attribute values
+      const autoAllowedTags = {};
+      Object.keys(editorRequiredTags).forEach((tag) => {
+        // If userAllowedTags does not contain a rule for this editor-required
+        // tag, then add it to the list of automatically allowed tags.
         if (!userAllowedTags.hasOwnProperty(tag)) {
           autoAllowedTags[tag] = editorRequiredTags[tag];
-        } else {
-          var requiredAttributes = editorRequiredTags[tag].restrictedTags.allowed.attributes;
-          var allowedAttributes = userAllowedTags[tag].restrictedTags.allowed.attributes;
-          var needsAdditionalAttributes = requiredAttributes.length && difference(requiredAttributes, allowedAttributes).length;
-          var requiredClasses = editorRequiredTags[tag].restrictedTags.allowed.classes;
-          var allowedClasses = userAllowedTags[tag].restrictedTags.allowed.classes;
-          var needsAdditionalClasses = requiredClasses.length && difference(requiredClasses, allowedClasses).length;
+        }
+        // Otherwise, if userAllowedTags already allows this tag, then check if
+        // additional attributes and classes on this tag are required by the
+        // editor.
+        else {
+          const requiredAttributes =
+            editorRequiredTags[tag].restrictedTags.allowed.attributes;
+          const allowedAttributes =
+            userAllowedTags[tag].restrictedTags.allowed.attributes;
+          const needsAdditionalAttributes =
+            requiredAttributes.length &&
+            difference(requiredAttributes, allowedAttributes).length;
+          const requiredClasses =
+            editorRequiredTags[tag].restrictedTags.allowed.classes;
+          const allowedClasses =
+            userAllowedTags[tag].restrictedTags.allowed.classes;
+          const needsAdditionalClasses =
+            requiredClasses.length &&
+            difference(requiredClasses, allowedClasses).length;
           if (needsAdditionalAttributes || needsAdditionalClasses) {
             autoAllowedTags[tag] = userAllowedTags[tag].clone();
           }
           if (needsAdditionalAttributes) {
-            autoAllowedTags[tag].restrictedTags.allowed.attributes = [].concat(_toConsumableArray(allowedAttributes), _toConsumableArray(requiredAttributes));
+            autoAllowedTags[tag].restrictedTags.allowed.attributes = [
+              ...allowedAttributes,
+              ...requiredAttributes,
+            ];
           }
           if (needsAdditionalClasses) {
-            autoAllowedTags[tag].restrictedTags.allowed.classes = [].concat(_toConsumableArray(allowedClasses), _toConsumableArray(requiredClasses));
+            autoAllowedTags[tag].restrictedTags.allowed.classes = [
+              ...allowedClasses,
+              ...requiredClasses,
+            ];
           }
         }
       });
+
       return autoAllowedTags;
     },
-    _parseSetting: function _parseSetting(setting) {
-      var tag;
-      var rule;
-      var attributes;
-      var attribute;
-      var allowedTags = setting.match(/(<[^>]+>)/g);
-      var rules = {};
-      for (var t = 0; t < allowedTags.length; t++) {
-        var $tagObject = $(allowedTags[t]);
+
+    /**
+     * Parses the value of this.$allowedHTMLFormItem.
+     *
+     * @param {string} setting
+     *   The string representation of the setting. For example:
+     *     <p class="callout"> <br> <a href hreflang>
+     *
+     * @return {Object.<string, Drupal.FilterHTMLRule>}
+     *   The corresponding text filter HTML rule objects, one per tag, keyed by
+     *   tag name.
+     */
+    _parseSetting(setting) {
+      let tag;
+      let rule;
+      let attributes;
+      let attribute;
+
+      const allowedTags = setting.match(/(<[^>]+>)/g);
+      const rules = {};
+      for (let t = 0; t < allowedTags.length; t++) {
+        // Create a jQuery object, making it possible to easily retrieve the
+        // tag name of the allowed tag, regardless of what attributes are set or
+        // what its required parent elements are.
+        const $tagObject = $(allowedTags[t]);
+
+        // Parse the tag name from the jQuery object.
         tag = $tagObject.prop('tagName').toLowerCase();
+
+        // Build the Drupal.FilterHtmlRule object.
         rule = new Drupal.FilterHTMLRule();
+        // We create one rule per allowed tag, so always one tag.
         rule.restrictedTags.tags = [tag];
+
+        // Add the attribute restrictions.
         attributes = $tagObject.prop('attributes');
-        for (var i = 0; i < attributes.length; i++) {
+        for (let i = 0; i < attributes.length; i++) {
           attribute = attributes.item(i);
-          var attributeName = attribute.nodeName;
+          const attributeName = attribute.nodeName;
+          // @todo Drupal.FilterHtmlRule does not allow for generic attribute
+          //   value restrictions, only for the "class" and "style" attribute's
+          //   values. The filter_html filter always disallows the "style"
+          //   attribute, so we only need to support "class" attribute value
+          //   restrictions. Fix once https://www.drupal.org/node/2567801 lands.
           if (attributeName === 'class') {
-            var attributeValue = attribute.textContent;
+            const attributeValue = attribute.textContent;
             rule.restrictedTags.allowed.classes = attributeValue.split(' ');
           } else {
             rule.restrictedTags.allowed.attributes.push(attributeName);
           }
         }
+
         rules[tag] = rule;
       }
       return rules;
     },
-    _generateSetting: function _generateSetting(tags) {
-      return Object.keys(tags).reduce(function (setting, tag) {
-        var rule = tags[tag];
-        var allowedClasses = rule.restrictedTags.allowed.classes;
+
+    /**
+     * Generates the value of this.$allowedHTMLFormItem.
+     *
+     * @param {Object.<string, Drupal.FilterHTMLRule>} tags
+     *   The parsed representation of the setting.
+     *
+     * @return {Array}
+     *   The string representation of the setting. e.g. "<p> <br> <a>"
+     */
+    _generateSetting(tags) {
+      return Object.keys(tags).reduce((setting, tag) => {
+        const rule = tags[tag];
+        const allowedClasses = rule.restrictedTags.allowed.classes;
+
         if (setting.length) {
           setting += ' ';
         }
-        setting += "<".concat(tag);
+
+        setting += `<${tag}`;
         if (rule.restrictedTags.allowed.attributes.length) {
-          setting += " ".concat(rule.restrictedTags.allowed.attributes.join(' '));
+          setting += ` ${rule.restrictedTags.allowed.attributes.join(' ')}`;
         }
+        // @todo Drupal.FilterHtmlRule does not allow for generic attribute
+        //   value restrictions, only for the "class" and "style" attribute's
+        //   values. The filter_html filter always disallows the "style"
+        //   attribute, so we only need to support "class" attribute value
+        //   restrictions. Fix once https://www.drupal.org/node/2567801 lands.
         if (allowedClasses.length === 1 && allowedClasses[0] === '') {
           setting += ' class';
         } else if (allowedClasses.length) {
-          setting += " class=\"".concat(allowedClasses.join(' '), "\"");
+          setting += ' class="'.concat(allowedClasses.join(' '), '"');
         }
+
         setting += '>';
         return setting;
       }, '');
-    }
+    },
   };
+
+  /**
+   * Theme function for the filter_html update message.
+   *
+   * @param {Array} tags
+   *   An array of the new tags that are to be allowed.
+   *
+   * @return {string}
+   *   The corresponding HTML.
+   */
   Drupal.theme.filterFilterHTMLUpdateMessage = function (tags) {
-    var html = '';
-    var tagList = Drupal.behaviors.filterFilterHtmlUpdating._generateSetting(tags);
+    let html = '';
+    const tagList =
+      Drupal.behaviors.filterFilterHtmlUpdating._generateSetting(tags);
     html += '<p class="editor-update-message">';
-    html += Drupal.t('Based on the text editor configuration, these tags have automatically been added: <strong>@tag-list</strong>.', {
-      '@tag-list': tagList
-    });
+    html += Drupal.t(
+      'Based on the text editor configuration, these tags have automatically been added: <strong>@tag-list</strong>.',
+      { '@tag-list': tagList },
+    );
     html += '</p>';
     return html;
   };
-})(jQuery, Drupal, document);
\ No newline at end of file
+})(jQuery, Drupal, document);
diff --git a/web/core/modules/filter/filter.info.yml b/web/core/modules/filter/filter.info.yml
index 251b956d..7a292893 100644
--- a/web/core/modules/filter/filter.info.yml
+++ b/web/core/modules/filter/filter.info.yml
@@ -1,6 +1,6 @@
 name: Filter
 type: module
-description: 'Filters content in preparation for display.'
+description: 'Filters text content in preparation for display.'
 package: Core
 version: VERSION
 configure: filter.admin_overview
diff --git a/web/core/modules/filter/filter.js b/web/core/modules/filter/filter.js
index ca15f389..733dc93f 100644
--- a/web/core/modules/filter/filter.js
+++ b/web/core/modules/filter/filter.js
@@ -1,18 +1,39 @@
 /**
-* DO NOT EDIT THIS FILE.
-* See the following change record for more information,
-* https://www.drupal.org/node/2815083
-* @preserve
-**/
+ * @file
+ * Attaches behavior for the Filter module.
+ */
+
 (function ($, Drupal) {
+  /**
+   * Displays the guidelines of the selected text format automatically.
+   *
+   * @type {Drupal~behavior}
+   *
+   * @prop {Drupal~behaviorAttach} attach
+   *   Attaches behavior for updating filter guidelines.
+   */
   Drupal.behaviors.filterGuidelines = {
-    attach: function attach(context) {
+    attach(context) {
       function updateFilterGuidelines(event) {
-        var $this = $(event.target);
-        var value = event.target.value;
-        $this.closest('.js-filter-wrapper').find('[data-drupal-format-id]').hide().filter("[data-drupal-format-id=\"".concat(value, "\"]")).show();
+        const $this = $(event.target);
+        const { value } = event.target;
+        $this
+          .closest('.js-filter-wrapper')
+          .find('[data-drupal-format-id]')
+          .hide()
+          .filter(`[data-drupal-format-id="${value}"]`)
+          .show();
       }
-      $(once('filter-guidelines', '.js-filter-guidelines', context)).find(':header').hide().closest('.js-filter-wrapper').find('select.js-filter-list').on('change.filterGuidelines', updateFilterGuidelines).trigger('change.filterGuidelines');
-    }
+
+      $(once('filter-guidelines', '.js-filter-guidelines', context))
+        .find(':header')
+        .hide()
+        .closest('.js-filter-wrapper')
+        .find('select.js-filter-list')
+        .on('change.filterGuidelines', updateFilterGuidelines)
+        // Need to trigger the namespaced event to avoid triggering formUpdated
+        // when initializing the select.
+        .trigger('change.filterGuidelines');
+    },
   };
-})(jQuery, Drupal);
\ No newline at end of file
+})(jQuery, Drupal);
diff --git a/web/core/modules/filter/filter.libraries.yml b/web/core/modules/filter/filter.libraries.yml
index e3ef0d8b..108d6b92 100644
--- a/web/core/modules/filter/filter.libraries.yml
+++ b/web/core/modules/filter/filter.libraries.yml
@@ -6,7 +6,6 @@ drupal.filter.admin:
     - core/jquery
     - core/drupal
     - core/once
-    - core/jquery.once.bc
     - core/drupal.form
 
 drupal.filter.filter_html.admin:
@@ -16,8 +15,6 @@ drupal.filter.filter_html.admin:
   dependencies:
     - core/jquery
     - core/once
-    - core/jquery.once.bc
-    - core/drupal.array.includes
 
 drupal.filter:
   version: VERSION
@@ -27,7 +24,6 @@ drupal.filter:
     - core/jquery
     - core/drupal
     - core/once
-    - core/jquery.once.bc
 
 caption:
   version: VERSION
diff --git a/web/core/modules/filter/filter.module b/web/core/modules/filter/filter.module
index 4fcaca58..c7a1a14a 100644
--- a/web/core/modules/filter/filter.module
+++ b/web/core/modules/filter/filter.module
@@ -362,7 +362,7 @@ function template_preprocess_filter_guidelines(&$variables) {
     '#tips' => _filter_tips($format->id(), FALSE),
   ];
 
-  // Add format id for filter.es6.js.
+  // Add format id for filter.js.
   $variables['attributes']['data-drupal-format-id'] = $format->id();
 }
 
@@ -488,7 +488,7 @@ function _filter_url($text, $filter) {
   $valid_url_query_ending_chars = '[a-zA-Z0-9_&=#\/]';
 
   // full path
-  // and allow @ in a url, but only in the middle. Catch things like http://example.com/@user/
+  // and allow @ in a URL, but only in the middle. Catch things like http://example.com/@user/
   $valid_url_path = '(?:(?:' . $valid_url_path_characters . '*(?:' . $valid_url_balanced_parens . $valid_url_path_characters . '*)*' . $valid_url_ending_characters . ')|(?:@' . $valid_url_path_characters . '+\/))';
 
   // Prepare domain name pattern.
diff --git a/web/core/modules/filter/src/Entity/FilterFormat.php b/web/core/modules/filter/src/Entity/FilterFormat.php
index c975f718..cf03af72 100644
--- a/web/core/modules/filter/src/Entity/FilterFormat.php
+++ b/web/core/modules/filter/src/Entity/FilterFormat.php
@@ -297,10 +297,6 @@ public function getHtmlRestrictions() {
       $restrictions = array_reduce($filters, function ($restrictions, $filter) {
         $new_restrictions = $filter->getHTMLRestrictions();
 
-        if (isset($new_restrictions['forbidden_tags'])) {
-          @trigger_error('forbidden_tags for FilterInterface::getHTMLRestrictions() is deprecated in drupal:9.4.0 and is removed from drupal:10.0.0', E_USER_DEPRECATED);
-        }
-
         // The first filter with HTML restrictions provides the initial set.
         if (!isset($restrictions)) {
           return $new_restrictions;
@@ -309,16 +305,6 @@ public function getHtmlRestrictions() {
         // with the existing set, to ensure we only end up with the tags that are
         // allowed by *all* filters with an "allowed html" setting.
         else {
-          // Track the union of forbidden tags.
-          if (isset($new_restrictions['forbidden_tags'])) {
-            if (!isset($restrictions['forbidden_tags'])) {
-              $restrictions['forbidden_tags'] = $new_restrictions['forbidden_tags'];
-            }
-            else {
-              $restrictions['forbidden_tags'] = array_unique(array_merge($restrictions['forbidden_tags'], $new_restrictions['forbidden_tags']));
-            }
-          }
-
           // Track the intersection of allowed tags.
           if (isset($restrictions['allowed'])) {
             $intersection = $restrictions['allowed'];
@@ -376,31 +362,16 @@ public function getHtmlRestrictions() {
             $restrictions['allowed'] = $intersection;
           }
 
-          return $restrictions;
-        }
-      }, NULL);
-
-      // Simplification: if we have both allowed (intersected) and forbidden
-      // (unioned) tags, then remove any allowed tags that are also forbidden.
-      // Once complete, the list of allowed tags expresses all tag-level
-      // restrictions, and the list of forbidden tags can be removed.
-      if (isset($restrictions['allowed']) && isset($restrictions['forbidden_tags'])) {
-        foreach ($restrictions['forbidden_tags'] as $tag) {
-          if (isset($restrictions['allowed'][$tag])) {
-            unset($restrictions['allowed'][$tag]);
+          // Simplification: if the only remaining allowed tag is the asterisk
+          // (which contains attribute restrictions that apply to all tags),
+          // then effectively nothing is allowed.
+          if (count($restrictions['allowed']) === 1 && array_key_exists('*', $restrictions['allowed'])) {
+            $restrictions['allowed'] = [];
           }
-        }
-        unset($restrictions['forbidden_tags']);
-      }
 
-      // Simplification: if the only remaining allowed tag is the asterisk
-      // (which contains attribute restrictions that apply to all tags), and
-      // there are no forbidden tags, then effectively nothing is allowed.
-      if (isset($restrictions['allowed'])) {
-        if (count($restrictions['allowed']) === 1 && array_key_exists('*', $restrictions['allowed']) && !isset($restrictions['forbidden_tags'])) {
-          $restrictions['allowed'] = [];
+          return $restrictions;
         }
-      }
+      }, NULL);
 
       return $restrictions;
     }
diff --git a/web/core/modules/filter/src/FilterFormatInterface.php b/web/core/modules/filter/src/FilterFormatInterface.php
index 707776b3..62a704a6 100644
--- a/web/core/modules/filter/src/FilterFormatInterface.php
+++ b/web/core/modules/filter/src/FilterFormatInterface.php
@@ -72,10 +72,8 @@ public function getFilterTypes();
    *
    * @return array|false
    *   A structured array as returned by FilterInterface::getHTMLRestrictions(),
-   *   but with the intersection of all filters in this text format. The
-   *   restrictions will either forbid or allow a list of tags. In the latter
-   *   case, it's possible that restrictions on attributes are also stored.
-   *   FALSE means there are no HTML restrictions.
+   *   but with the intersection of all filters in this text format. FALSE means
+   *   there are no HTML restrictions.
    */
   public function getHtmlRestrictions();
 
diff --git a/web/core/modules/filter/src/Plugin/Filter/FilterCaption.php b/web/core/modules/filter/src/Plugin/Filter/FilterCaption.php
index 817f73b7..7847dbdf 100644
--- a/web/core/modules/filter/src/Plugin/Filter/FilterCaption.php
+++ b/web/core/modules/filter/src/Plugin/Filter/FilterCaption.php
@@ -95,7 +95,7 @@ public function process($text, $langcode) {
         // content editor from adding a new caption. To allow for this we treat
         // a raw caption value of ' ' as valid and adding the wrapping figure
         // element.
-        // @see core/modules/media/js/plugins/drupalmedia/plugin.es6.js
+        // @see core/modules/media/js/plugins/drupalmedia/plugin.js
         if (mb_strlen($caption) === 0 && $raw_caption !== ' ') {
           continue;
         }
diff --git a/web/core/modules/filter/src/Plugin/Filter/FilterHtml.php b/web/core/modules/filter/src/Plugin/Filter/FilterHtml.php
index e4474320..88cf3484 100644
--- a/web/core/modules/filter/src/Plugin/Filter/FilterHtml.php
+++ b/web/core/modules/filter/src/Plugin/Filter/FilterHtml.php
@@ -203,7 +203,7 @@ protected function findAllowedValue(array $allowed, $name) {
     }
     // Handle prefix (wildcard) matches.
     foreach ($allowed['prefix'] as $prefix => $value) {
-      if (strpos($name, $prefix) === 0) {
+      if (str_starts_with($name, $prefix)) {
         return $value;
       }
     }
diff --git a/web/core/modules/filter/src/Plugin/FilterInterface.php b/web/core/modules/filter/src/Plugin/FilterInterface.php
index eaae5e9c..7714f03e 100644
--- a/web/core/modules/filter/src/Plugin/FilterInterface.php
+++ b/web/core/modules/filter/src/Plugin/FilterInterface.php
@@ -184,9 +184,9 @@ public function process($text, $langcode);
    * format.
    *
    * @return array|false
-   *   A nested array with *either* of the following keys:
-   *     - 'allowed': (optional) the allowed tags as keys, and for each of those
-   *       tags (keys) either of the following values:
+   *   A nested array with the following structure:
+   *     - 'allowed': the allowed tags as keys, and for each of those tags
+   *       (keys) either of the following values:
    *       - TRUE to indicate any attribute is allowed
    *       - FALSE to indicate no attributes are allowed
    *       - an array to convey attribute restrictions: the keys must be
@@ -198,7 +198,6 @@ public function process($text, $langcode);
    *             be attribute values (which may use a wildcard, e.g. "xsd:*"),
    *             the possible values are TRUE or FALSE: to mark the attribute
    *             value as allowed or forbidden, respectively
-   *     -  'forbidden_tags': (deprecated) the forbidden tags
    *
    *   There is one special case: the "wildcard tag", "*": any attribute
    *   restrictions on that pseudotag apply to all tags.
@@ -226,13 +225,6 @@ public function process($text, $langcode);
    *           'src' => TRUE,
    *           'alt' => TRUE,
    *         ),
-   *         // Allow RDFa on <span> tags, using only the dc, foaf, xsd and sioc
-   *         // vocabularies/namespaces.
-   *         'span' => array(
-   *           'property' => array('dc:*' => TRUE, 'foaf:*' => TRUE),
-   *           'datatype' => array('xsd:*' => TRUE),
-   *           'rel' => array('sioc:*' => TRUE),
-   *         ),
    *         // Forbid the 'style' and 'on*' ('onClick' etc.) attributes on any
    *         // tag.
    *         '*' => array(
@@ -243,13 +235,6 @@ public function process($text, $langcode);
    *     )
    *     @endcode
    *
-   *   A simpler example, for a very coarse filter:
-   *     @code
-   *     array(
-   *       'forbidden_tags' => array('iframe', 'script')
-   *     )
-   *     @endcode
-   *
    *   The simplest example possible: a filter that doesn't allow any HTML:
    *     @code
    *     array(
diff --git a/web/core/modules/filter/src/Plugin/migrate/process/d6/FilterFormatPermission.php b/web/core/modules/filter/src/Plugin/migrate/process/d6/FilterFormatPermission.php
index 83e18c2c..357d3562 100644
--- a/web/core/modules/filter/src/Plugin/migrate/process/d6/FilterFormatPermission.php
+++ b/web/core/modules/filter/src/Plugin/migrate/process/d6/FilterFormatPermission.php
@@ -23,7 +23,7 @@ class FilterFormatPermission extends ProcessPluginBase implements ContainerFacto
   /**
    * The current migration.
    */
-  protected $migration;
+  protected MigrationInterface $migration;
 
   /**
    * The migrate lookup service.
diff --git a/web/core/modules/filter/tests/filter_test/config/schema/filter_test.schema.yml b/web/core/modules/filter/tests/filter_test/config/schema/filter_test.schema.yml
index 92e107f4..f54502c1 100644
--- a/web/core/modules/filter/tests/filter_test/config/schema/filter_test.schema.yml
+++ b/web/core/modules/filter/tests/filter_test/config/schema/filter_test.schema.yml
@@ -14,9 +14,3 @@ filter_settings.filter_test_restrict_tags_and_attributes:
           sequence:
             type: ignore
             label: 'Tag and optionally list of attributes'
-        forbidden_tags:
-          type: sequence
-          label: 'Forbidden tags'
-          sequence:
-            type: boolean
-            label: 'Tag'
diff --git a/web/core/modules/filter/tests/filter_test/src/Plugin/Filter/FilterTestRestrictTagsAndAttributes.php b/web/core/modules/filter/tests/filter_test/src/Plugin/Filter/FilterTestRestrictTagsAndAttributes.php
index c6f62009..13a91451 100644
--- a/web/core/modules/filter/tests/filter_test/src/Plugin/Filter/FilterTestRestrictTagsAndAttributes.php
+++ b/web/core/modules/filter/tests/filter_test/src/Plugin/Filter/FilterTestRestrictTagsAndAttributes.php
@@ -54,11 +54,6 @@ public function getHTMLRestrictions() {
         }
       }
     }
-    if (isset($restrictions['forbidden_tags'])) {
-      foreach ($restrictions['forbidden_tags'] as $tag => $bool) {
-        $restrictions['forbidden_tags'][$tag] = (bool) $bool;
-      }
-    }
 
     return $restrictions;
   }
diff --git a/web/core/modules/filter/tests/src/Functional/FilterSecurityTest.php b/web/core/modules/filter/tests/src/Functional/FilterSecurityTest.php
index 156b2f7c..ebe5a787 100644
--- a/web/core/modules/filter/tests/src/Functional/FilterSecurityTest.php
+++ b/web/core/modules/filter/tests/src/Functional/FilterSecurityTest.php
@@ -96,8 +96,8 @@ public function testDisableFilterModule() {
   public function testSkipSecurityFilters() {
     $text = "Text with some disallowed tags: <script />, <p><object>unicorn</object></p>, <i><table></i>.";
     $expected_filtered_text = "Text with some disallowed tags: , <p>unicorn</p>, .";
-    $this->assertEquals($expected_filtered_text, check_markup($text, 'filtered_html', '', []), 'Expected filter result.');
-    $this->assertEquals($expected_filtered_text, check_markup($text, 'filtered_html', '', [FilterInterface::TYPE_HTML_RESTRICTOR]), 'Expected filter result, even when trying to disable filters of the FilterInterface::TYPE_HTML_RESTRICTOR type.');
+    $this->assertSame($expected_filtered_text, (string) check_markup($text, 'filtered_html', '', []), 'Expected filter result.');
+    $this->assertSame($expected_filtered_text, (string) check_markup($text, 'filtered_html', '', [FilterInterface::TYPE_HTML_RESTRICTOR]), 'Expected filter result, even when trying to disable filters of the FilterInterface::TYPE_HTML_RESTRICTOR type.');
   }
 
 }
diff --git a/web/core/modules/filter/tests/src/FunctionalJavascript/FilterHtmlTest.php b/web/core/modules/filter/tests/src/FunctionalJavascript/FilterHtmlTest.php
index ac418911..7a76907f 100644
--- a/web/core/modules/filter/tests/src/FunctionalJavascript/FilterHtmlTest.php
+++ b/web/core/modules/filter/tests/src/FunctionalJavascript/FilterHtmlTest.php
@@ -2,7 +2,6 @@
 
 namespace Drupal\Tests\filter\FunctionalJavascript;
 
-use Drupal\editor\Entity\Editor;
 use Drupal\filter\Entity\FilterFormat;
 use Drupal\FunctionalJavascriptTests\WebDriverTestBase;
 
@@ -50,44 +49,4 @@ public function testTableTags() {
     $this->assertJsCondition($js_condition);
   }
 
-  /**
-   * Tests the Allowed Tags configuration with CSS classes.
-   *
-   * @group legacy
-   */
-  public function testStylesToAllowedTagsSync() {
-    \Drupal::service('module_installer')->install(['ckeditor']);
-    FilterFormat::create([
-      'format' => 'some_html',
-      'name' => 'Some HTML',
-      'filters' => [
-        'filter_html' => [
-          'status' => 1,
-          'settings' => [
-            'allowed_html' => '<span class>',
-          ],
-        ],
-      ],
-    ])->save();
-
-    Editor::create([
-      'format' => 'some_html',
-      'editor' => 'ckeditor',
-      'settings' => [
-        'plugins' => [
-          'stylescombo' => [
-            'styles' => 'span.hello-world|Hello World',
-          ],
-        ],
-      ],
-    ])->save();
-
-    $this->drupalLogin($this->drupalCreateUser(['administer filters']));
-    $this->drupalGet('admin/config/content/formats/manage/some_html');
-
-    $js_condition = "jQuery('#edit-filters-filter-html-settings-allowed-html').val() === \"<span class> <strong> <em> <a href> <ul> <li> <ol> <blockquote> <img src alt data-entity-type data-entity-uuid>\"";
-
-    $this->assertJsCondition($js_condition);
-  }
-
 }
diff --git a/web/core/modules/filter/tests/src/Kernel/FilterAPITest.php b/web/core/modules/filter/tests/src/Kernel/FilterAPITest.php
index ca7996d3..3170ee88 100644
--- a/web/core/modules/filter/tests/src/Kernel/FilterAPITest.php
+++ b/web/core/modules/filter/tests/src/Kernel/FilterAPITest.php
@@ -71,15 +71,15 @@ public function testCheckMarkupFilterSubset() {
     $expected_filter_text_without_html_generators = "Text with evil content and a URL: https://www.drupal.org!";
 
     $actual_filtered_text = check_markup($text, 'filtered_html', '', []);
-    $this->assertEquals($expected_filtered_text, $actual_filtered_text, 'Expected filter result.');
+    $this->assertSame($expected_filtered_text, (string) $actual_filtered_text, 'Expected filter result.');
     $actual_filtered_text_without_html_generators = check_markup($text, 'filtered_html', '', [FilterInterface::TYPE_MARKUP_LANGUAGE]);
-    $this->assertEquals($expected_filter_text_without_html_generators, $actual_filtered_text_without_html_generators, 'Expected filter result when skipping FilterInterface::TYPE_MARKUP_LANGUAGE filters.');
+    $this->assertSame($expected_filter_text_without_html_generators, (string) $actual_filtered_text_without_html_generators, 'Expected filter result when skipping FilterInterface::TYPE_MARKUP_LANGUAGE filters.');
     // Related to @see FilterSecurityTest.php/testSkipSecurityFilters(), but
     // this check focuses on the ability to filter multiple filter types at once.
     // Drupal core only ships with these two types of filters, so this is the
     // most extensive test possible.
     $actual_filtered_text_without_html_generators = check_markup($text, 'filtered_html', '', [FilterInterface::TYPE_HTML_RESTRICTOR, FilterInterface::TYPE_MARKUP_LANGUAGE]);
-    $this->assertEquals($expected_filter_text_without_html_generators, $actual_filtered_text_without_html_generators, 'Expected filter result when skipping FilterInterface::TYPE_MARKUP_LANGUAGE filters, even when trying to disable filters of the FilterInterface::TYPE_HTML_RESTRICTOR type.');
+    $this->assertSame($expected_filter_text_without_html_generators, (string) $actual_filtered_text_without_html_generators, 'Expected filter result when skipping FilterInterface::TYPE_MARKUP_LANGUAGE filters, even when trying to disable filters of the FilterInterface::TYPE_HTML_RESTRICTOR type.');
   }
 
   /**
@@ -141,8 +141,11 @@ public function testFilterFormatAPI() {
     $stupid_filtered_html_format->save();
     $this->assertSame(
       $stupid_filtered_html_format->getHtmlRestrictions(),
-      // No tag is allowed.
-      ['allowed' => []],
+      [
+        'allowed' => [
+          '*' => ['style' => FALSE, 'on*' => FALSE, 'lang' => TRUE, 'dir' => ['ltr' => TRUE, 'rtl' => TRUE]],
+        ],
+      ],
       'FilterFormatInterface::getHtmlRestrictions() works as expected for the stupid_filtered_html format.'
     );
     $this->assertSame(
@@ -315,7 +318,7 @@ public function testProcessedTextElement() {
     ];
     $this->assertEqualsCanonicalizing($expected_cache_contexts, $build['#cache']['contexts'], 'Expected cache contexts present.');
     $expected_markup = '<p>Hello, world!</p><p>This is a dynamic llama.</p>';
-    $this->assertEquals($expected_markup, $build['#markup'], 'Expected #lazy_builder callback has been applied.');
+    $this->assertSame($expected_markup, (string) $build['#markup'], 'Expected #lazy_builder callback has been applied.');
   }
 
   /**
@@ -327,9 +330,12 @@ public function testTypedDataAPI() {
 
     $this->assertInstanceOf(OptionsProviderInterface::class, $data);
 
-    $filtered_html_user = $this->createUser(['uid' => 2], [
-      FilterFormat::load('filtered_html')->getPermissionName(),
-    ]);
+    $filtered_html_user = $this->createUser(
+      [FilterFormat::load('filtered_html')->getPermissionName()],
+      NULL,
+      FALSE,
+      ['uid' => 2]
+    );
 
     // Test with anonymous user.
     $user = new AnonymousUserSession();
@@ -514,28 +520,4 @@ public function testSleep() {
     $this->assertNotContains('filterCollection', $vars);
   }
 
-  /**
-   * Tests deprecated "forbidden tags" functionality.
-   *
-   * @group legacy
-   */
-  public function testForbiddenTagsDeprecated(): void {
-    $this->expectDeprecation('forbidden_tags for FilterInterface::getHTMLRestrictions() is deprecated in drupal:9.4.0 and is removed from drupal:10.0.0');
-    FilterFormat::create([
-      'format' => 'forbidden_tags_deprecation_test',
-      'name' => 'Forbidden tags deprecation test',
-      'filters' => [
-        'filter_test_restrict_tags_and_attributes' => [
-          'status' => TRUE,
-          'settings' => [
-            'restrictions' => [
-              'forbidden_tags' => ['p' => FALSE],
-            ],
-          ],
-        ],
-      ],
-    ])->save();
-    FilterFormat::load('forbidden_tags_deprecation_test')->getHtmlRestrictions();
-  }
-
 }
diff --git a/web/core/modules/filter/tests/src/Kernel/FilterKernelTest.php b/web/core/modules/filter/tests/src/Kernel/FilterKernelTest.php
index 5c1c7696..0fa0d288 100644
--- a/web/core/modules/filter/tests/src/Kernel/FilterKernelTest.php
+++ b/web/core/modules/filter/tests/src/Kernel/FilterKernelTest.php
@@ -737,7 +737,7 @@ public function testUrlFilter() {
       ],
       '<p>Test &lt;br/&gt;: This is a www.example17.com example <strong>with</strong> various http://www.example18.com tags. *<br/>
        It is important www.example19.com to *<br/>test different URLs and http://www.example20.com in the same paragraph. *<br>
-      HTML www.example21.com soup by person@example22.com can litererally http://www.example23.com contain *img*<img> anything. Just a www.example24.com with http://www.example25.com thrown in. www.example26.com from person@example27.com with extra http://www.example28.com.
+       HTML www.example21.com soup by person@example22.com can literally http://www.example23.com contain *img*<img> anything. Just a www.example24.com with http://www.example25.com thrown in. www.example26.com from person@example27.com with extra http://www.example28.com.
       ' => [
         'href="http://www.example17.com"' => TRUE,
         'href="http://www.example18.com"' => TRUE,
@@ -1015,23 +1015,23 @@ public function testHtmlCorrectorFilter() {
 
     $f = Html::normalize('<script>alert("test")</script>');
     $this->assertEquals('<script>
-<!--//--><![CDATA[// ><!--
+//<![CDATA[
 alert("test")
-//--><!]]>
+//]]>
 </script>', $f, 'HTML corrector -- CDATA added to script element');
 
     $f = Html::normalize('<p><script>alert("test")</script></p>');
     $this->assertEquals('<p><script>
-<!--//--><![CDATA[// ><!--
+//<![CDATA[
 alert("test")
-//--><!]]>
+//]]>
 </script></p>', $f, 'HTML corrector -- CDATA added to a nested script element');
 
     $f = Html::normalize('<p><style> /* Styling */ body {color:red}</style></p>');
     $this->assertEquals('<p><style>
-<!--/*--><![CDATA[/* ><!--*/
+/*<![CDATA[*/
  /* Styling */ body {color:red}
-/*--><!]]>*/
+/*]]>*/
 </style></p>', $f, 'HTML corrector -- CDATA added to a style element.');
 
     $filtered_data = Html::normalize('<p><style>
@@ -1041,50 +1041,38 @@ public function testHtmlCorrectorFilter() {
 /*]]>*/
 </style></p>');
     $this->assertEquals('<p><style>
-<!--/*--><![CDATA[/* ><!--*/
-
 /*<![CDATA[*/
 /* Styling */
 body {color:red}
-/*]]]]><![CDATA[>*/
-
-/*--><!]]>*/
+/*]]>*/
 </style></p>', $filtered_data,
       new FormattableMarkup('HTML corrector -- Existing cdata section @pattern_name properly escaped', ['@pattern_name' => '/*<![CDATA[*/'])
     );
 
     $filtered_data = Html::normalize('<p><style>
-  <!--/*--><![CDATA[/* ><!--*/
+/*<![CDATA[*/
   /* Styling */
   body {color:red}
-  /*--><!]]>*/
+/*]]>*/
 </style></p>');
     $this->assertEquals('<p><style>
-<!--/*--><![CDATA[/* ><!--*/
-
-  <!--/*--><![CDATA[/* ><!--*/
+/*<![CDATA[*/
   /* Styling */
   body {color:red}
-  /*--><!]]]]><![CDATA[>*/
-
-/*--><!]]>*/
+/*]]>*/
 </style></p>', $filtered_data,
       new FormattableMarkup('HTML corrector -- Existing cdata section @pattern_name properly escaped', ['@pattern_name' => '<!--/*--><![CDATA[/* ><!--*/'])
     );
 
     $filtered_data = Html::normalize('<p><script>
-<!--//--><![CDATA[// ><!--
+//<![CDATA[
   alert("test");
-//--><!]]>
+//]]>
 </script></p>');
     $this->assertEquals('<p><script>
-<!--//--><![CDATA[// ><!--
-
-<!--//--><![CDATA[// ><!--
+//<![CDATA[
   alert("test");
-//--><!]]]]><![CDATA[>
-
-//--><!]]>
+//]]>
 </script></p>', $filtered_data,
       new FormattableMarkup('HTML corrector -- Existing cdata section @pattern_name properly escaped', ['@pattern_name' => '<!--//--><![CDATA[// ><!--'])
     );
@@ -1092,27 +1080,52 @@ public function testHtmlCorrectorFilter() {
     $filtered_data = Html::normalize('<p><script>
 // <![CDATA[
   alert("test");
-// ]]>
+//]]>
 </script></p>');
     $this->assertEquals('<p><script>
-<!--//--><![CDATA[// ><!--
-
 // <![CDATA[
   alert("test");
-// ]]]]><![CDATA[>
-
-//--><!]]>
+//]]>
 </script></p>', $filtered_data,
       new FormattableMarkup('HTML corrector -- Existing cdata section @pattern_name properly escaped', ['@pattern_name' => '// <![CDATA['])
     );
 
+    $filtered_data = Html::normalize('<p><script>
+// <![CDATA[![CDATA[![CDATA[
+  alert("test");
+//]]]]]]>
+</script></p>');
+    $this->assertEquals('<p><script>
+// <![CDATA[![CDATA[![CDATA[
+  alert("test");
+//]]]]]]>
+</script></p>', $filtered_data,
+      new FormattableMarkup('HTML corrector -- Existing cdata section @pattern_name properly escaped', ['@pattern_name' => '// <![CDATA[![CDATA[![CDATA['])
+    );
+
+    // Test calling Html::normalize() twice.
+    $filtered_data = Html::normalize('<p><script>
+// <![CDATA[![CDATA[![CDATA[
+  alert("test");
+//]]]]]]>
+</script></p>');
+    $filtered_data = Html::normalize($filtered_data);
+
+    $this->assertEquals('<p><script>
+// <![CDATA[![CDATA[![CDATA[
+  alert("test");
+//]]]]]]>
+</script></p>', $filtered_data,
+      new FormattableMarkup('HTML corrector -- Existing cdata section @pattern_name properly escaped', ['@pattern_name' => '// <![CDATA[![CDATA[![CDATA['])
+    );
+
   }
 
   /**
    * Asserts that a text transformed to lowercase with HTML entities decoded does contains a given string.
    *
    * Otherwise fails the test with a given message, similar to all the
-   * SimpleTest assert* functions.
+   * PHPUnit assert* functions.
    *
    * Note that this does not remove nulls, new lines and other characters that
    * could be used to obscure a tag or an attribute name.
@@ -1123,12 +1136,10 @@ public function testHtmlCorrectorFilter() {
    *   Lowercase, plain text to look for.
    * @param string $message
    *   (optional) Message to display if failed. Defaults to an empty string.
-   * @param string $group
-   *   (optional) The group this message belongs to. Defaults to 'Other'.
    *
    * @internal
    */
-  public function assertNormalized(string $haystack, string $needle, string $message = '', string $group = 'Other'): void {
+  public function assertNormalized(string $haystack, string $needle, string $message = ''): void {
     $this->assertStringContainsString($needle, strtolower(Html::decodeEntities($haystack)), $message);
   }
 
@@ -1136,7 +1147,7 @@ public function assertNormalized(string $haystack, string $needle, string $messa
    * Asserts that text transformed to lowercase with HTML entities decoded does not contain a given string.
    *
    * Otherwise fails the test with a given message, similar to all the
-   * SimpleTest assert* functions.
+   * PHPUnit assert* functions.
    *
    * Note that this does not remove nulls, new lines, and other character that
    * could be used to obscure a tag or an attribute name.
@@ -1147,12 +1158,10 @@ public function assertNormalized(string $haystack, string $needle, string $messa
    *   Lowercase, plain text to look for.
    * @param string $message
    *   (optional) Message to display if failed. Defaults to an empty string.
-   * @param string $group
-   *   (optional) The group this message belongs to. Defaults to 'Other'.
    *
    * @internal
    */
-  public function assertNoNormalized(string $haystack, string $needle, string $message = '', string $group = 'Other'): void {
+  public function assertNoNormalized(string $haystack, string $needle, string $message = ''): void {
     $this->assertStringNotContainsString($needle, strtolower(Html::decodeEntities($haystack)), $message);
   }
 
diff --git a/web/core/modules/filter/tests/src/Kernel/Migrate/d6/FilterFormatPermissionTest.php b/web/core/modules/filter/tests/src/Kernel/Migrate/d6/FilterFormatPermissionTest.php
index dcdf97b9..e3dff111 100644
--- a/web/core/modules/filter/tests/src/Kernel/Migrate/d6/FilterFormatPermissionTest.php
+++ b/web/core/modules/filter/tests/src/Kernel/Migrate/d6/FilterFormatPermissionTest.php
@@ -24,7 +24,6 @@ public function testConfigurableFilterFormat() {
     $migration = Migration::create($this->container, [], 'custom_migration', []);
     $filterFormatPermissionMigration = FilterFormatPermission::create($this->container, ['migration' => 'custom_filter_format'], 'custom_filter_format', [], $migration);
     $reflected_config = new \ReflectionProperty($filterFormatPermissionMigration, 'configuration');
-    $reflected_config->setAccessible(TRUE);
     $config = $reflected_config->getValue($filterFormatPermissionMigration);
     $this->assertEquals('custom_filter_format', $config['migration']);
   }
diff --git a/web/core/modules/filter/tests/src/Kernel/Plugin/migrate/process/FilterSettingsTest.php b/web/core/modules/filter/tests/src/Kernel/Plugin/migrate/process/FilterSettingsTest.php
index 636850c8..51592ee8 100644
--- a/web/core/modules/filter/tests/src/Kernel/Plugin/migrate/process/FilterSettingsTest.php
+++ b/web/core/modules/filter/tests/src/Kernel/Plugin/migrate/process/FilterSettingsTest.php
@@ -24,7 +24,7 @@ class FilterSettingsTest extends MigrateTestCase {
    */
   public function testTransform($value, $destination_id, $expected_value) {
     $migration = $this->createMock(MigrationInterface::class);
-    $plugin = new FilterSettings([], 'filter_settings', [], $migration);
+    $plugin = new FilterSettings([], 'filter_settings', []);
 
     $executable = $this->createMock(MigrateExecutableInterface::class);
     $row = $this->getMockBuilder(Row::class)
diff --git a/web/core/modules/filter/tests/src/Kernel/TextFormatElementFormTest.php b/web/core/modules/filter/tests/src/Kernel/TextFormatElementFormTest.php
index 4c76151e..061b5896 100644
--- a/web/core/modules/filter/tests/src/Kernel/TextFormatElementFormTest.php
+++ b/web/core/modules/filter/tests/src/Kernel/TextFormatElementFormTest.php
@@ -132,13 +132,4 @@ public function testTextFormatElement() {
     $this->assertNoPattern('|<h4[^>]*></h4>|', 'No empty H4 element found.');
   }
 
-  /**
-   * {@inheritdoc}
-   */
-  protected function getUrl() {
-    // \Drupal\simpletest\AssertContentTrait needs this for ::assertFieldByName
-    // to work.
-    return 'Internal rendering';
-  }
-
 }
